-- espstb (fixed & complete)
-- Features: Chams, Names, Tracers, Boxes, Health Bars
-- Drawing API based, per-player storage, updates each RenderStepped

local ESP = {}
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- States
local states = {
    chams = false,
    names = false,
    tracers = false,
    boxes = false,
    healthbars = false,
    teamcheck = false,
    whitelist = false,
}

-- Colors
local colors = {
    chamsFill = Color3.fromRGB(0,200,255),
    chamsOutline = Color3.fromRGB(255,255,255),
    tracer = Color3.fromRGB(0,200,255),
    name = Color3.fromRGB(255,255,255),
    box = Color3.fromRGB(255,255,255),
    healthbar = Color3.fromRGB(0,255,0),
}

-- Storage
local highlights = {} -- Roblox Highlight objects
local drawings = {}   -- [Player] = {text,line,box,hpLine}
local whitelist = {}

----------------------------------------------------------------
-- Helpers
----------------------------------------------------------------
local function isWhitelisted(plr)
    return states.whitelist and whitelist[plr.UserId]
end

local function isSameTeam(plr)
    return states.teamcheck and LocalPlayer.Team and plr.Team and LocalPlayer.Team == plr.Team
end

local function safeDestroy(obj)
    if obj and obj.Destroy then pcall(function() obj:Destroy() end) end
end

local function makeDrawing(kind, props)
    local d = Drawing.new(kind)
    for k,v in pairs(props) do
        pcall(function() d[k] = v end)
    end
    return d
end

local function clearDrawings(plr)
    if drawings[plr] then
        for _,d in pairs(drawings[plr]) do
            pcall(function() d:Remove() end)
        end
    end
    drawings[plr] = nil
end

local function ensureDrawings(plr)
    if not drawings[plr] then
        drawings[plr] = {
            text = makeDrawing("Text",{Size=16,Center=true,Outline=true,Visible=false}),
            line = makeDrawing("Line",{Thickness=1.5,Visible=false}),
            box = makeDrawing("Square",{Thickness=1,Visible=false,Filled=false}),
            hpLine = makeDrawing("Line",{Thickness=4,Visible=false}),
        }
    end
    return drawings[plr]
end

local function addHighlight(plr)
    safeDestroy(highlights[plr])
    if not plr.Character then return end
    local h = Instance.new("Highlight")
    h.FillColor = colors.chamsFill
    h.OutlineColor = colors.chamsOutline
    h.Adornee = plr.Character
    h.Parent = plr.Character
    highlights[plr] = h
end

local function removeHighlight(plr)
    safeDestroy(highlights[plr])
    highlights[plr] = nil
end

----------------------------------------------------------------
-- Render loop
----------------------------------------------------------------
RunService.RenderStepped:Connect(function()
    for _,plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and not isWhitelisted(plr) and not isSameTeam(plr) then
            local head = plr.Character:FindFirstChild("Head")
            local root = plr.Character:FindFirstChild("HumanoidRootPart")
            local hum = plr.Character:FindFirstChildOfClass("Humanoid")
            if head and root then
                local pos,onScreen = Camera:WorldToViewportPoint(head.Position)
                local objs = ensureDrawings(plr)
                if onScreen then
                    -- Names
                    objs.text.Visible = states.names
                    if states.names then
                        objs.text.Text = plr.Name
                        objs.text.Position = Vector2.new(pos.X, pos.Y-20)
                        objs.text.Color = colors.name
                    end

                    -- Tracers
                    objs.line.Visible = states.tracers
                    if states.tracers then
                        objs.line.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                        objs.line.To = Vector2.new(pos.X,pos.Y)
                        objs.line.Color = colors.tracer
                    end

                    -- Boxes & HP
                    objs.box.Visible = states.boxes
                    objs.hpLine.Visible = states.healthbars
                    if states.boxes or states.healthbars then
                        local cf = root.CFrame
                        local size = Vector3.new(2,3,1.5)
                        local corners = {
                            cf * Vector3.new(-1,-1.5,-0.75),
                            cf * Vector3.new(-1, 1.5,-0.75),
                            cf * Vector3.new( 1, 1.5,-0.75),
                            cf * Vector3.new( 1,-1.5,-0.75),
                            cf * Vector3.new(-1,-1.5, 0.75),
                            cf * Vector3.new(-1, 1.5, 0.75),
                            cf * Vector3.new( 1, 1.5, 0.75),
                            cf * Vector3.new( 1,-1.5, 0.75),
                        }
                        local screenCorners = {}
                        for _,c in ipairs(corners) do
                            local sp = Camera:WorldToViewportPoint(c)
                            table.insert(screenCorners,Vector2.new(sp.X,sp.Y))
                        end
                        local minX,minY,maxX,maxY=math.huge,math.huge,-math.huge,-math.huge
                        for _,v in ipairs(screenCorners) do
                            minX, minY = math.min(minX,v.X), math.min(minY,v.Y)
                            maxX, maxY = math.max(maxX,v.X), math.max(maxY,v.Y)
                        end
                        if states.boxes then
                            objs.box.Position = Vector2.new(minX,minY)
                            objs.box.Size = Vector2.new(maxX-minX,maxY-minY)
                            objs.box.Color = colors.box
                        end
                        if states.healthbars and hum then
                            local ratio = hum.Health / (hum.MaxHealth>0 and hum.MaxHealth or 1)
                            objs.hpLine.From = Vector2.new(minX-6,maxY)
                            objs.hpLine.To = Vector2.new(minX-6,maxY-(maxY-minY)*ratio)
                            objs.hpLine.Color = colors.healthbar
                        end
                    end
                else
                    objs.text.Visible = false
                    objs.line.Visible = false
                    objs.box.Visible = false
                    objs.hpLine.Visible = false
                end
            end
        else
            clearDrawings(plr)
        end
    end
end)

----------------------------------------------------------------
-- Wiring for chams on respawn
----------------------------------------------------------------
local function hookPlayer(plr)
    plr.CharacterAdded:Connect(function()
        task.wait(0.2)
        if states.chams then addHighlight(plr) end
    end)
end
Players.PlayerAdded:Connect(hookPlayer)
for _,plr in ipairs(Players:GetPlayers()) do if plr~=LocalPlayer then hookPlayer(plr) end end
Players.PlayerRemoving:Connect(function(plr)
    clearDrawings(plr)
    removeHighlight(plr)
    whitelist[plr.UserId] = nil
end)

----------------------------------------------------------------
-- Public API
----------------------------------------------------------------
function ESP:ToggleChams(s) states.chams = s~=nil and s or not states.chams
    if states.chams then for _,plr in ipairs(Players:GetPlayers()) do if plr~=LocalPlayer and plr.Character then addHighlight(plr) end end
    else for _,hl in pairs(highlights) do safeDestroy(hl) end highlights={} end
    return states.chams
end
function ESP:ToggleNames(s) states.names=s~=nil and s or not states.names return states.names end
function ESP:ToggleTracers(s) states.tracers=s~=nil and s or not states.tracers return states.tracers end
function ESP:ToggleBoxes(s) states.boxes=s~=nil and s or not states.boxes return states.boxes end
function ESP:ToggleHealthBars(s) states.healthbars=s~=nil and s or not states.healthbars return states.healthbars end
function ESP:ToggleTeamCheck(s) states.teamcheck=s~=nil and s or not states.teamcheck return states.teamcheck end
function ESP:ToggleWhitelist(s) states.whitelist=s~=nil and s or not states.whitelist return states.whitelist end

-- Colors
function ESP:SetChamsFillColor(c) colors.chamsFill=c for _,h in pairs(highlights) do h.FillColor=c end end
function ESP:SetChamsOutlineColor(c) colors.chamsOutline=c for _,h in pairs(highlights) do h.OutlineColor=c end end
function ESP:SetTracerColor(c) colors.tracer=c end
function ESP:SetNameColor(c) colors.name=c end
function ESP:SetBoxColor(c) colors.box=c end
function ESP:SetHealthbarColor(c) colors.healthbar=c end

-- Whitelist
function ESP:AddWhitelistUserId(id) whitelist[id]=true return true end
function ESP:RemoveWhitelistUserId(id) whitelist[id]=nil return true end
function ESP:GetWhitelistUserIds() local out={} for id in pairs(whitelist) do table.insert(out,id) end return out end

return ESP
