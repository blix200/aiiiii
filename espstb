-- espstb (fixed + extended)
-- Features: Chams (Highlight), Names, Tracers, Boxes, Health Bars
-- Supports: RGB setters, team check, whitelist, Add/Remove whitelist entries
-- Uses Drawing API for names/tracers/boxes/healthbars

local ESP = {}
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- States
local states = {
    chams = false,
    names = false,
    tracers = false,
    boxes = false,
    healthbars = false,
    teamcheck = false,
    whitelist = false,
}

-- Colors (defaults)
local colors = {
    chamsFill = Color3.fromRGB(0,200,255),
    chamsOutline = Color3.fromRGB(255,255,255),
    tracer = Color3.fromRGB(0,200,255),
    name = Color3.fromRGB(255,255,255),
    box = Color3.fromRGB(255,255,255),
    healthbar = Color3.fromRGB(0,255,0),
}

-- Internal storage
local drawings = {}           -- per-frame drawing objects
local highlights = {}         -- Highlight instances keyed by Player
local whitelist = {}          -- userId -> true

----------------------------------------------------------------
-- Utility
----------------------------------------------------------------
local function isWhitelisted(plr)
    if not states.whitelist then return false end
    return whitelist[plr.UserId] == true
end

local function isSameTeam(plr)
    if not states.teamcheck then return false end
    if LocalPlayer.Team and plr.Team then
        return LocalPlayer.Team == plr.Team
    end
    return false
end

local function safeDestroy(obj)
    if obj and obj.Destroy then
        pcall(function() obj:Destroy() end)
    end
end

local function addHighlightForPlayer(plr)
    -- create or refresh highlight for a player's current character
    safeDestroy(highlights[plr])
    if not plr.Character then return end
    local ok, hl = pcall(function()
        local h = Instance.new("Highlight")
        h.FillColor = colors.chamsFill
        h.OutlineColor = colors.chamsOutline
        h.Adornee = plr.Character
        h.Parent = plr.Character
        return h
    end)
    if ok and hl then highlights[plr] = hl end
end

local function removeHighlightForPlayer(plr)
    safeDestroy(highlights[plr])
    highlights[plr] = nil
end

----------------------------------------------------------------
-- Drawing loop (names / tracers / boxes / healthbars)
----------------------------------------------------------------
RunService.RenderStepped:Connect(function()
    -- remove previous drawings
    for i=1, #drawings do
        local d = drawings[i]
        pcall(function() d:Remove() end)
    end
    drawings = {}

    local players = Players:GetPlayers()
    local viewSize = Camera.ViewportSize

    for _, plr in ipairs(players) do
        if plr ~= LocalPlayer and plr.Character then
            -- skip if whitelisted or same team (when toggled)
            if isWhitelisted(plr) or isSameTeam(plr) then
                -- skip drawing
            else
                local head = plr.Character:FindFirstChild("Head")
                local root = plr.Character:FindFirstChild("HumanoidRootPart")
                local hum = plr.Character:FindFirstChildOfClass("Humanoid")
                if head and root then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                    if onScreen then
                        -- helper to create and store drawing safely
                        local function newDrawing(kind, props)
                            local ok, d = pcall(function() return Drawing.new(kind) end)
                            if not ok or not d then return nil end
                            for k,v in pairs(props) do
                                pcall(function() d[k] = v end)
                            end
                            table.insert(drawings, d)
                            return d
                        end

                        -- Name
                        if states.names then
                            newDrawing("Text", {
                                Text = plr.Name,
                                Position = Vector2.new(screenPos.X, screenPos.Y - 20),
                                Color = colors.name,
                                Size = 16,
                                Center = true,
                                Outline = true,
                                Visible = true,
                            })
                        end

                        -- Tracer
                        if states.tracers then
                            newDrawing("Line", {
                                From = Vector2.new(viewSize.X/2, viewSize.Y),
                                To = Vector2.new(screenPos.X, screenPos.Y),
                                Color = colors.tracer,
                                Thickness = 1.5,
                                Visible = true,
                            })
                        end

                        -- Box & Health
                        if states.boxes or states.healthbars then
                            -- compute AABB box screen rect using 8 corners
                            local cframe = root.CFrame
                            local size = Vector3.new(2, 3, 1.5) -- rough avatar size, works for most
                            local corners = {
                                cframe * Vector3.new(-size.X/2, -size.Y/2, -size.Z/2),
                                cframe * Vector3.new(-size.X/2,  size.Y/2, -size.Z/2),
                                cframe * Vector3.new( size.X/2,  size.Y/2, -size.Z/2),
                                cframe * Vector3.new( size.X/2, -size.Y/2, -size.Z/2),
                                cframe * Vector3.new(-size.X/2, -size.Y/2,  size.Z/2),
                                cframe * Vector3.new(-size.X/2,  size.Y/2,  size.Z/2),
                                cframe * Vector3.new( size.X/2,  size.Y/2,  size.Z/2),
                                cframe * Vector3.new( size.X/2, -size.Y/2,  size.Z/2),
                            }
                            local screenCorners = {}
                            for _, corner in ipairs(corners) do
                                local sp, vis = Camera:WorldToViewportPoint(corner)
                                table.insert(screenCorners, Vector2.new(sp.X, sp.Y))
                            end

                            local minX, minY = math.huge, math.huge
                            local maxX, maxY = -math.huge, -math.huge
                            for _, v in ipairs(screenCorners) do
                                minX = math.min(minX, v.X)
                                minY = math.min(minY, v.Y)
                                maxX = math.max(maxX, v.X)
                                maxY = math.max(maxY, v.Y)
                            end

                            if states.boxes then
                                newDrawing("Square", {
                                    Position = Vector2.new(minX, minY),
                                    Size = Vector2.new(math.max(1, maxX - minX), math.max(1, maxY - minY)),
                                    Color = colors.box,
                                    Thickness = 1,
                                    Filled = false,
                                    Visible = true,
                                })
                            end

                            if states.healthbars and hum then
                                local hp = 0
                                pcall(function() hp = math.clamp(hum.Health / (hum.MaxHealth > 0 and hum.MaxHealth or 1), 0, 1) end)
                                local barHeight = (maxY - minY) * hp
                                newDrawing("Line", {
                                    From = Vector2.new(minX - 6, maxY),
                                    To = Vector2.new(minX - 6, maxY - barHeight),
                                    Color = colors.healthbar,
                                    Thickness = 4,
                                    Visible = true,
                                })
                            end
                        end
                    end
                end
            end
        end
    end
end)

----------------------------------------------------------------
-- Player/Character wiring
----------------------------------------------------------------
local function onPlayerAdded(plr)
    -- ensure highlight is refreshed when character spawns
    plr.CharacterAdded:Connect(function(char)
        -- small delay for char to settle
        task.wait(0.25)
        if states.chams and char then
            addHighlightForPlayer(plr)
        end
    end)
    -- if chams already enabled and they have character now, create highlight
    if states.chams and plr.Character then
        addHighlightForPlayer(plr)
    end
end

Players.PlayerAdded:Connect(function(plr) onPlayerAdded(plr) end)
Players.PlayerRemoving:Connect(function(plr)
    removeHighlightForPlayer(plr)
    whitelist[plr.UserId] = nil
end)

-- attach for existing players now
for _,plr in ipairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then onPlayerAdded(plr) end
end

----------------------------------------------------------------
-- Toggle functions (exposed)
----------------------------------------------------------------
function ESP:ToggleChams(state)
    states.chams = (state ~= nil) and state or not states.chams
    if states.chams then
        for _,plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                addHighlightForPlayer(plr)
            end
        end
    else
        for plr,_ in pairs(highlights) do
            removeHighlightForPlayer(plr)
        end
    end
    return states.chams
end

function ESP:ToggleNames(state)
    states.names = (state ~= nil) and state or not states.names
    return states.names
end

function ESP:ToggleTracers(state)
    states.tracers = (state ~= nil) and state or not states.tracers
    return states.tracers
end

function ESP:ToggleBoxes(state)
    states.boxes = (state ~= nil) and state or not states.boxes
    return states.boxes
end

function ESP:ToggleHealthBars(state)
    states.healthbars = (state ~= nil) and state or not states.healthbars
    return states.healthbars
end

function ESP:ToggleTeamCheck(state)
    states.teamcheck = (state ~= nil) and state or not states.teamcheck
    return states.teamcheck
end

function ESP:ToggleWhitelist(state)
    states.whitelist = (state ~= nil) and state or not states.whitelist
    return states.whitelist
end

----------------------------------------------------------------
-- Whitelist management
----------------------------------------------------------------
function ESP:AddWhitelistUserId(id)
    if type(id) ~= "number" then return false end
    whitelist[id] = true
    return true
end
function ESP:RemoveWhitelistUserId(id)
    whitelist[id] = nil
    return true
end
function ESP:GetWhitelistUserIds()
    local out = {}
    for id,_ in pairs(whitelist) do table.insert(out, id) end
    return out
end

----------------------------------------------------------------
-- Color setters (exposed)
----------------------------------------------------------------
function ESP:SetChamsFillColor(c) colors.chamsFill = c; for plr,hl in pairs(highlights) do pcall(function() hl.FillColor = c end) end end
function ESP:SetChamsOutlineColor(c) colors.chamsOutline = c; for plr,hl in pairs(highlights) do pcall(function() hl.OutlineColor = c end) end end
function ESP:SetTracerColor(c) colors.tracer = c end
function ESP:SetNameColor(c) colors.name = c end
function ESP:SetBoxColor(c) colors.box = c end
function ESP:SetHealthbarColor(c) colors.healthbar = c end

----------------------------------------------------------------
-- Safe accessor for states (optional)
----------------------------------------------------------------
function ESP:GetStates()
    local copy = {}
    for k,v in pairs(states) do copy[k] = v end
    return copy
end

return ESP
